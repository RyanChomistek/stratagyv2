#pragma kernel CSMain

RWStructuredBuffer<float> heightMap;
RWStructuredBuffer<float> waterMap;
int mapSize;

int numThreads;

int maxLifetime;
float inertia;

float evaporateSpeed;
float gravity;
float startSpeed;
float startWater;

uint4 seed;
int numDropletsPerThread;

float RunWeight;
float StopWeight;

bool InBounds(int i, int mapSize)
{
	return i > 0 && i < mapSize;
}

static bool CheckIfInboundsForGradient(float posX, float posY, int mapSize)
{
	int coordX = (int)posX;
	int coordY = (int)posY;

	// Calculate droplet's offset inside the cell (0,0) = at NW node, (1,1) = at SE node
	float x = posX - coordX;
	float y = posY - coordY;

	int nodeIndexNW = coordY * mapSize + coordX;
	int nodeIndexNE = nodeIndexNW + 1;
	int nodeIndexSW = nodeIndexNW + mapSize;
	int nodeIndexSE = nodeIndexNW + mapSize + 1;

	int arrayLen = mapSize * mapSize;

	return InBounds(nodeIndexNW, arrayLen) && InBounds(nodeIndexNE, arrayLen) && InBounds(nodeIndexSW, arrayLen) && InBounds(nodeIndexSE, arrayLen);
}

// Returns float3(gradientX, gradientY, height)
float3 CalculateHeightAndGradient(float posX, float posY) {
	int coordX = (int)posX;
	int coordY = (int)posY;

	if (!CheckIfInboundsForGradient(posX, posY, mapSize))
	{
		return float3(0, 0, heightMap[coordY * mapSize + coordX]);
	}

	// Calculate droplet's offset inside the cell (0,0) = at NW node, (1,1) = at SE node
	float x = posX - coordX;
	float y = posY - coordY;

	// Calculate heights of the four nodes of the droplet's cell
	int nodeIndexNW = coordY * mapSize + coordX;
	float heightNW = heightMap[nodeIndexNW];
	float heightNE = heightMap[nodeIndexNW + 1];
	float heightSW = heightMap[nodeIndexNW + mapSize];
	float heightSE = heightMap[nodeIndexNW + mapSize + 1];

	// Calculate droplet's direction of flow with bilinear interpolation of height difference along the edges
	float gradientX = (heightNE - heightNW) * (1 - y) + (heightSE - heightSW) * y;
	float gradientY = (heightSW - heightNW) * (1 - x) + (heightSE - heightNE) * x;

	// Calculate height with bilinear interpolation of the heights of the nodes of the cell
	float height = heightNW * (1 - x) * (1 - y) + heightNE * x * (1 - y) + heightSW * (1 - x) * y + heightSE * x * y;

	return float3(gradientX, gradientY, height);
}

uint TausStep(uint z, int S1, int S2, int S3, uint M)
{
	uint b = (((z << S1) ^ z) >> S2);
	return ((z & M) << S3) ^ b;
}

uint LCGStep(uint z, uint A, uint C)
{
	return A * z + C;
}

struct RandomResult
{
	uint4 state;
	float value;
};

RandomResult HybridTaus(uint4 state)
{
	state.x = TausStep(state.x, 13, 19, 12, 4294967294);
	state.y = TausStep(state.y, 2, 25, 4, 4294967288);
	state.z = TausStep(state.z, 3, 11, 17, 4294967280);
	state.w = LCGStep(state.w, 1664525, 1013904223);

	RandomResult rand;
	rand.state = state;
	rand.value = 2.3283064365387e-10 * (state.x ^ state.y ^ state.z ^ state.w);

	return rand;
}

uint Random(uint idx, uint idy, uint max)
{
	seed.x += idx;
	seed.y += idy;
	seed.z += (uint)(sin(idx * 71.01) * 5061564);
	seed.w += (uint)(cos(idy * 23.7) * 10267329);

	return (uint) (HybridTaus(seed).value * max);
}

[numthreads(1, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	int mapBufferLength = mapSize * mapSize;

	for (int dropletCnt = 0; dropletCnt < numDropletsPerThread; dropletCnt++)
	{
		uint idx = id.x * 4026739;
		uint idy = (dropletCnt * 7002353);
		int index = Random(idx, idy, mapBufferLength);
		
		float posX = float(index) % mapSize;
		float posY = float(index) / mapSize;
		float speed = startSpeed;
		float water = startWater;
		float2 dir = float2(0, 0);

		for (int lifetime = 0; lifetime < maxLifetime; lifetime++)
		{
			int nodeX = (int)posX;
			int nodeY = (int)posY;
			int dropletIndex = nodeY * mapSize + nodeX;
			//waterMap[dropletIndex] = lifetime;

			// Calculate droplet's offset inside the cell (0,0) = at NW node, (1,1) = at SE node
			float cellOffsetX = posX - nodeX;
			float cellOffsetY = posY - nodeY;

			// Calculate droplet's height and direction of flow with bilinear interpolation of surrounding heights
			float3 heightAndGradient = CalculateHeightAndGradient(posX, posY);

			// Update the droplet's direction and position (move position 1 unit regardless of speed)
			dir = (dir * inertia) - (heightAndGradient.xy * (1 - inertia));
			dir = normalize(dir);

			posX += dir.x;
			posY += dir.y;

			// Stop simulating droplet if it's not moving or has flowed over edge of map
			if (dir.x == 0 && dir.y == 0)
			{
				waterMap[dropletIndex] += water * StopWeight;
				break;
			}

			if (posX > mapSize || posX < 0 || posY > mapSize || posY < 0)
			{
				break;
			}

			// Find the droplet's new height and calculate the deltaHeight
			float newHeight = CalculateHeightAndGradient(posX, posY).z;
			float deltaHeight = newHeight - heightAndGradient.z;

			// Update droplet's speed and water content
			speed = sqrt(max(0, speed * speed + deltaHeight * gravity));
			water *= (1 - evaporateSpeed);
			waterMap[dropletIndex] += water * RunWeight;

			if (lifetime == maxLifetime - 1)
			{
				waterMap[dropletIndex] += water * StopWeight;
			}
		}
	}
}
